#!/usr/bin/env python3
"""
Exploit Generation - Record Trace

This example demonstrates how to trace program execution with Manticore.
It records all executed instructions and identifies the crash point.

Usage:
    python record_trace.py ./bof AAAAAAAAAAAAAAAAAAAAAAA

Challenge Type: Program Tracing
Platform: Linux x86
"""

import os
import sys
from manticore.native import Manticore
from manticore.utils import log


def record_execution():
    """Record execution trace for crash analysis."""
    
    # Get binary path
    script_dir = os.path.dirname(os.path.abspath(__file__))
    binary_path = os.path.join(script_dir, "bof")
    
    print("=" * 60)
    print("Exploit Generation - Trace Recording")
    print("=" * 60)
    
    # Parse arguments
    if len(sys.argv) > 1 and sys.argv[1] != "--test":
        prog = sys.argv[1]
        params = sys.argv[2:]
    else:
        # Default test case
        prog = binary_path
        params = ["AAAAAAAAAAAAAAAAAAAAAAA"]
        
        print("[*] Running with default test case")
        print(f"    Binary: {prog}")
        print(f"    Input: {params[0]}")
    
    # Initialize Manticore
    m = Manticore(prog, params)
    log.set_verbosity(2)  # verbosity method is deprecated
    
    # 'trace' will contain the executed instructions
    m.context["trace"] = []
    
    # None: The hook will be applied to all the instructions
    @m.hook(None)
    def record_trace(state):
        pc = state.cpu.PC
        ins = state.cpu.instruction
        
        # Store the instruction
        with m.locked_context() as c:
            c["trace"] += [pc]
            
            # We manipulate directly capstone instruction
            c["last_ins"] = "%s %s" % (ins.mnemonic, ins.op_str)
    
    # Run the program
    print("\n[*] Starting trace recording...")
    m.run()
    
    # Print results
    print("\n[*] Trace recording complete!")
    print(f"    {len(m.context['trace'])} instructions recorded")
    print(f"    Last instruction executed:")
    print(f"    0x{m.context['trace'][-1]:x}: {m.context['last_ins']}")
    
    # Check if we hit the expected crash
    if m.context["last_ins"] == "call eax":
        print("\n[+] Crash detected at indirect call!")
        print("    This is exploitable - EAX can be controlled")
        return True
    else:
        print("\n[!] Unexpected termination")
        return False


if __name__ == "__main__":
    record_execution()